---
description:
globs:
alwaysApply: false
---
# Advanced Alchemy and Litestar Service/Repository/Model Patterns (with msgspec)

## Objective
To ensure robust, maintainable, and efficient database interactions by consistently applying the project's established Advanced Alchemy patterns for SQLAlchemy models, Litestar services (with inner repositories), and mandatory `msgspec.Struct` DTOs. **The patterns found in `UserService`, `TeamService`, and the `User`, `Team`, `Tag` models are the de-facto standard.**

## Context
- **Technologies**: Advanced Alchemy, SQLAlchemy 2.0, Litestar, `msgspec`.
- **Advanced Alchemy Docs**: [https://docs.advanced-alchemy.litestar.dev/latest/](mdc:https:/docs.advanced-alchemy.litestar.dev/latest)
- **Key Project Patterns**:
    - Services inherit `litestar.plugins.sqlalchemy.service.SQLAlchemyAsyncRepositoryService`.
    - Services define an inner `Repo` class inheriting `litestar.plugins.sqlalchemy.repository.SQLAlchemyAsyncRepository` (or `...SlugRepository`).
    - Models use Advanced Alchemy base classes (e.g., `UUIDAuditBase`) and mixins (e.g., `SlugKey`, `UniqueMixin`).
    - `msgspec.Struct` is **mandatory** for API DTOs.
- **Project Files**: Model definitions (`src/py/app/db/models/`), service implementations (`src/py/app/services/`), `msgspec.Struct` definitions (`src/py/app/schemas/`).

## Rules

### SQLAlchemy Models (`src/py/app/db/models/`)
- **Base Models**: All SQLAlchemy declarative models MUST inherit from an appropriate Advanced Alchemy base model (e.g., `UUIDAuditBase` as seen in `User` and `Team`).
    - ✅ `class User(UUIDAuditBase): ...`
    - ✅ `class Team(UUIDAuditBase, SlugKey): ...`
- **Mixins**: Utilize Advanced Alchemy mixins like `SlugKey` (as in `Team`, `Tag`) and `UniqueMixin` (as in `Tag`) when their functionality is required.
    - `UniqueMixin` is crucial for "get-or-create" M2M scenarios (e.g., tags). It requires implementing `unique_hash` and `unique_filter` methods on the model.
    - ✅
      ```python
      # In models/tag.py
      from advanced_alchemy.mixins import UniqueMixin, SlugKey
      from advanced_alchemy.base import UUIDAuditBase
      from advanced_alchemy.utils.text import slugify
      from sqlalchemy import ColumnElement # type: ignore[attr-defined]
      from collections.abc import Hashable

      class Tag(UUIDAuditBase, SlugKey, UniqueMixin):
          # ... other attributes ...
          @classmethod
          def unique_hash(cls, name: str, slug: str | None = None, **kwargs: object) -> Hashable: # Added **kwargs
              return slugify(name) # Example hash based on slugified name

          @classmethod
          def unique_filter(cls, name: str | None = None, slug: str | None = None, **kwargs: object) -> ColumnElement[bool]: # Added **kwargs and made params optional
              if name is not None: # Ensure at least one is provided for filter
                return cls.slug == slugify(name) # Filter by slug
              if slug is not None:
                return cls.slug == slug
              raise ValueError("Either name or slug must be provided for unique_filter")

      ```
- **Typing**: Use `sqlalchemy.orm.Mapped` and `mapped_column` for all model attributes.
- **Relationships**: Define relationships using `sqlalchemy.orm.relationship`. Prefer `lazy="selectin"` for frequently accessed relationships to avoid N+1 queries, as seen in `User.roles` and `User.teams`.

### Service Layer (`src/py/app/services/`)
- **Base Service Class**: All services MUST inherit from `litestar.plugins.sqlalchemy.service.SQLAlchemyAsyncRepositoryService[ModelType]` (e.g., `UserService(service.SQLAlchemyAsyncRepositoryService[m.User])`).
- **Inner Repository Class**: Each service MUST define an inner class named `Repo` that inherits from `litestar.plugins.sqlalchemy.repository.SQLAlchemyAsyncRepository[ModelType]` (e.g., `UserService.Repo`) or `SQLAlchemyAsyncSlugRepository[ModelType]` if slug functionality is needed (e.g., `TeamService.Repo`).
    - The service's `repository_type` attribute MUST be set to this inner `Repo` class.
    - ✅
      ```python
      # In services/_users.py
      from litestar.plugins.sqlalchemy import repository, service
      from app.db import models as m

      class UserService(service.SQLAlchemyAsyncRepositoryService[m.User]):
          class Repo(repository.SQLAlchemyAsyncRepository[m.User]):
              model_type = m.User
          repository_type = Repo
          # ... rest of the service ...
      ```
    - ✅
      ```python
      # In services/_teams.py
      from litestar.plugins.sqlalchemy import repository, service
      from app.db import models as m

      class TeamService(service.SQLAlchemyAsyncRepositoryService[m.Team]):
          class Repo(repository.SQLAlchemyAsyncSlugRepository[m.Team]): # Note SlugRepository
              model_type = m.Team
          repository_type = Repo
          # ... rest of the service ...
      ```
- **Data Transformation Hooks**: Utilize `to_model_on_create`, `to_model_on_update`, and `to_model_on_upsert` service hooks for data manipulation and preparation *before* data is passed to the repository. This is where `msgspec.Struct` data from controllers is processed or mapped to model-compatible dictionaries if needed.
    - These hooks often call internal `_populate_*` helper methods within the service (e.g., `_populate_slug`, `_populate_with_hashed_password`).
    - **Mapping `msgspec.Struct` to Model**: Within these hooks, or before calling repository methods, convert incoming `msgspec.Struct` data to a dictionary suitable for model instantiation or repository operations if the service base class doesn't handle `msgspec.Struct` directly. `msgspec.to_builtins(struct_instance)` can be used, or direct field access.
      ```python
      # Example within a to_model_on_create hook or service method
      # data: UserCreateStruct (msgspec.Struct)
      # model_data_dict = msgspec.to_builtins(data) # Converts to dict
      # # Now model_data_dict can be used to create a SQLAlchemy model instance
      # # or passed to repository methods that expect dicts.
      # # The SQLAlchemyAsyncRepositoryService might also directly handle attribute access
      # # from msgspec.Struct if field names align.
      ```
- **Business Logic**: Implement specific business logic methods within the service (e.g., `authenticate`, `update_password` in `UserService`; handling M2M tag logic using `Tag.as_unique_async` in `TeamService`).
- **`msgspec.Struct` for I/O**: Services should expect `msgspec.Struct` instances as input for create/update operations (coming from Litestar controllers) and are responsible for mapping SQLAlchemy model instances to `msgspec.Struct` instances for output if the controller doesn't handle this explicitly.

### Litestar Integration (SQLAlchemyPlugin)
- The `SQLAlchemyPlugin` from `advanced_alchemy.extensions.litestar` MUST be correctly configured in the Litestar application setup (e.g., in `src/py/app/plugins/db.py` or `asgi.py`).
    - This plugin provides the `AsyncSession` for dependency injection into services, which then pass it to their repositories (typically via `self.repository.session`).

## Mandatory `msgspec` Usage
- All Data Transfer Objects (DTOs) used at the API boundary (controller request/response types) MUST be `msgspec.Struct` instances. See `.cursor/rules/domain/data_validation.mdc` for `msgspec.Struct` definition guidelines.

## Exceptions
- Alembic migration scripts operate directly with SQLAlchemy Core/ORM and do not involve services or `msgspec` DTOs.
- CLI commands might interact directly with services, but their input parsing is distinct from API DTO validation.
