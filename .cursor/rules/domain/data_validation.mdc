---
description:
globs:
alwaysApply: false
---
# Data Validation with msgspec.Struct

## Objective
To ensure all incoming and outgoing API data is validated correctly and efficiently using `msgspec.Struct` as the primary mechanism for Data Transfer Objects (DTOs) / Schemas. **It is mandatory to use `msgspec.Struct` instead of Pydantic for core data structures.**

## Context
- **Technology**: `msgspec` for data validation and serialization.
- Litestar has built-in, high-performance support for `msgspec`.
- Schemas (Structs) should be defined in a dedicated module, e.g., `src/py/app/schemas/` or feature-specific schema modules.

## Rules

### Struct Definition
- **Use `msgspec.Struct`**: Define clear `msgspec.Struct` types for all API request and response bodies.
    - ✅
      ```python
      import msgspec
      from uuid import UUID
      from datetime import datetime

      class UserBase(msgspec.Struct, gc=False, array_like=True, omit_defaults=True):
          email: str
          name: str | None = None

      class UserCreate(UserBase):
          password: str

      class UserUpdate(msgspec.Struct, gc=False, array_like=True, omit_defaults=True):
          email: str | None = None
          name: str | None = None
          password: str | None = None # Example, might be handled differently
          is_active: bool | None = None

      class UserRead(UserBase):
          id: UUID
          is_active: bool
          created_at: datetime
          updated_at: datetime
      ```
- **Field Types**: Use standard Python types and `msgspec` specific types where appropriate. `msgspec` handles many common types efficiently.
- **Constraints**: `msgspec` supports constraints (e.g., `min_len`, `max_len`, `pattern` for strings; `ge`, `le` for numbers) directly in field definitions or via `Meta`.
    - ✅ `email: str = msgspec.field(pattern=r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$")` (or use a library for email validation if complex rules are needed)
- **Optional Fields & Defaults**: Use `| None = None` for optional fields with no default, or provide a default value. `omit_defaults=True` in `Struct` options is useful for PATCH-like operations.
- **Read-Only/Write-Only Fields**: Manage these by defining separate structs for Read, Create, and Update operations.
- **Struct Options**: Utilize `msgspec.Struct` options like `gc=False` (disables cyclic GC tracking for performance if struct is simple), `array_like=True` (for tuple-like representations, can be faster), `omit_defaults=True` (omits fields with default values during encoding if they match the default).

### Usage in Litestar
- **Automatic Validation & Serialization**: Litestar automatically validates incoming request data against `msgspec.Struct` type hints in route handlers and serializes return values of `msgspec.Struct` type.
    - ✅
      ```python
      from litestar import post, get
      from uuid import UUID
      from app.schemas import UserCreate, UserRead # Your msgspec structs
      from app.services import UserService # Your service

      @post("/users")
      async def create_user(data: UserCreate, user_service: UserService) -> UserRead:
          # 'data' is automatically validated instance of UserCreate
          new_user = await user_service.create_user(data)
          return UserRead(id=new_user.id, email=new_user.email, ...) # Map model to UserRead struct

      @get("/users/{user_id:uuid}")
      async def get_user(user_id: UUID, user_service: UserService) -> UserRead:
          user = await user_service.get_user(user_id)
          return UserRead(id=user.id, email=user.email, ...) # Map model to UserRead struct
      ```
- **Generic Structs**: `msgspec` supports generic structs, which can be useful for common response patterns (e.g., paginated responses).

### Naming Conventions
- Suffix struct names with `Read`, `Create`, `Update`, `Payload`, etc., to clearly indicate their purpose (e.g., `UserCreate`, `ItemRead`). Avoid generic `DTO` or `Schema` if a more specific suffix is clearer.

### Conversion Between Models and Structs
- **Service Layer Responsibility**: The service layer is often responsible for converting between SQLAlchemy models and `msgspec.Struct` instances.
    - For creation/update: `Service` receives a `Struct` from the controller, potentially converts/maps its fields to a model instance or a dictionary for the repository.
    - For reads: `Service` gets a model instance from the repository and converts it to a `Struct` before returning to the controller.
    - ✅
      ```python
      # Example in a service method
      # async def get_user(...) -> UserRead:
      #     db_user = await self.repository.get_one(id=user_id)
      #     return UserRead(id=db_user.id, email=db_user.email, ...)
      ```
- **Helper Functions**: Consider helper functions or methods for complex mappings between models and structs if direct instantiation becomes verbose.

## Exceptions
- Simple query parameters might use basic type hints directly in Litestar handler signatures if a full `msgspec.Struct` is overkill.
- Internal data structures not exposed via API might use other types (e.g., `dataclasses`) if `msgspec` features aren't needed, but for API boundaries, `msgspec` is mandatory.
