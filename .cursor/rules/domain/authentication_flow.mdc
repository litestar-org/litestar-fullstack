---
description: 
globs: 
alwaysApply: false
---
# Authentication and Authorization Flow

## Objective
To define and standardize the project's authentication (AuthN) and authorization (AuthZ) flow. This document details the interaction between User models, services, Data Transfer Objects (DTOs), Litestar's security mechanisms (JWT), and password management. This pattern is the de-facto standard for authentication using Litestar with SQLAlchemy and Advanced Alchemy in this project.

## Context
- **Primary Technologies**: Litestar, Advanced Alchemy, SQLAlchemy.
- **Authentication Mechanism**: JSON Web Tokens (JWT) via Litestar's `OAuth2PasswordBearerAuth`.
- **Password Hashing**: `pwdlib` (specifically Argon2) managed through `app.lib.crypt`.
- **Data Transfer Objects (DTOs)**: `msgspec.Struct` for all API request/response bodies related to authentication.

## Key Files & Components

-   **User Model**: `src/py/app/db/models/user.py` (Defines the `User` database schema).
-   **OAuth Account Model**: `src/py/app/db/models/oauth_account.py` (For third-party OAuth integrations, linked to `User`).
-   **Account Schemas**: `src/py/app/schemas/accounts.py` (Contains `msgspec.Struct` definitions like `AccountLogin`, `UserCreate`, `UserRead`).
-   **User Service**: `src/py/app/services/_users.py` (Contains `UserService` with core logic like `authenticate`, password hashing hooks).
-   **Cryptography Library**: `src/py/app/lib/crypt.py` (Handles password hashing and verification using `pwdlib`).
-   **Security Configuration**: `src/py/app/server/security.py` (Defines the `OAuth2PasswordBearerAuth` instance (`auth`), the `current_user_from_token` handler, and various security guards like `requires_active_user`).
-   **Access Routes**: `src/py/app/server/routes/access.py` (Contains `AccessController` for `/api/access/login` and `/api/access/signup`).
-   **Profile Routes**: `src/py/app/server/routes/profile.py` (Contains `ProfileController` for user profile management like `/api/me`).
-   **Dependency Providers**: `src/py/app/server/deps.py` (e.g., `provide_users_service`), `app.server.security.provide_user`.

## Rules and Detailed Flow

### 1. User Model (`app.db.models.user.User`)
-   The `User` model is central to authentication. Critical fields include:
    -   `email`: Unique identifier used as the username.
    -   `hashed_password`: Stores the securely hashed password.
    -   `is_active`: Boolean indicating if the user account can log in.
    -   `is_verified`: Boolean for email verification status (if applicable).
    -   `is_superuser`: Boolean for superuser privileges.
    -   Relationships like `roles` and `teams` are used for authorization.
-   It inherits from Advanced Alchemy's `UUIDAuditBase`.

### 2. Password Management (`app.lib.crypt` & `UserService`)
-   **Hashing**: When a user signs up or updates their password, `UserService` (e.g., in `_populate_with_hashed_password` hook or `update_password` method) calls `app.lib.crypt.get_password_hash()` to hash the plain-text password using Argon2.
-   **Verification**: During login, `UserService.authenticate()` calls `app.lib.crypt.verify_password()` to compare the provided password against the stored hash.

### 3. Login Flow (`POST /api/access/login`)
-   **Controller**: `AccessController.login` handles the request.
-   **Request DTO**: Expects `app.schemas.accounts.AccountLogin` (`msgspec.Struct`) containing `username` (email) and `password`.
-   **Authentication Logic**: Calls `UserService.authenticate(username, password)`.
    -   This service method retrieves the user by email.
    -   Verifies the password using `crypt.verify_password()`.
    -   Checks if the user is active.
    -   Raises `PermissionDeniedException` if authentication fails (user not found, password mismatch, inactive account).
-   **JWT Generation**: If authentication is successful, `security.auth.login(user.email)` is called. `security.auth` is the `OAuth2PasswordBearerAuth` instance.
    -   This generates a JWT. The `user.email` is used as the token's subject (`sub`).
-   **Response**: The endpoint returns an `OAuth2Login` response (a Litestar type often aliased or used directly), which includes the `access_token` (the JWT) and `token_type` (typically "Bearer").

### 4. User Registration Flow (`POST /api/access/signup`)
-   **Controller**: `AccessController.signup` handles the request.
-   **Request DTO**: Expects `app.schemas.accounts.AccountRegister` (`msgspec.Struct`).
-   **User Creation**: Calls `UserService.create(data)`, where `data` includes email, password, etc.
    -   `UserService` internally hashes the password via its `to_model_on_create` hook (calling `_populate_with_hashed_password`).
    -   A default role (e.g., `constants.DEFAULT_ACCESS_ROLE`) is typically assigned.
-   **Event Emission**: `request.app.emit("user_created", user_id=user.id)` is called to signal user creation for potential post-registration tasks.
-   **Response**: Returns the created user's details, typically mapped to `s.User` schema.

### 5. JWT Configuration (`security.auth` in `app.server.security.py`)
-   An instance of `OAuth2PasswordBearerAuth[m.User]` is created and named `auth`.
-   **`retrieve_user_handler`**: Set to `current_user_from_token`. This function is responsible for fetching the `User` model from the database based on the validated token.
-   **`token_secret`**: Loaded from `settings.app.SECRET_KEY`. This key is crucial for signing and verifying JWTs.
-   **`token_url`**: Set to `/api/access/login`, informing clients where to obtain a token.
-   **`exclude`**: A list of paths (e.g., `/api/health`, `/api/access/login`, `/api/access/signup`, schema docs) that do not require authentication.

### 6. Authenticated Requests & Token Validation
-   The client sends the JWT in the `Authorization` header for protected routes: `Authorization: Bearer <your_jwt_token>`.
-   The `OAuth2PasswordBearerAuth` middleware, configured on the Litestar application, automatically intercepts requests to protected routes.
-   It validates the token's signature, expiry, and other claims.
-   If the token is valid, it calls the `retrieve_user_handler` (`current_user_from_token`).

### 7. User Retrieval from Token (`current_user_from_token`)
-   This function receives the validated `Token` object (from Litestar).
-   It extracts the subject (`token.sub`), which is the user's email.
-   It uses `UserService` (obtained via `deps.provide_users_service` and a database session) to fetch the `m.User` from the database using the email.
-   Returns the `m.User` instance if found and active, otherwise returns `None` (which Litestar handles as an authentication failure).

### 8. Accessing the Current User in Route Handlers
-   Once `current_user_from_token` successfully returns a user, Litestar attaches this `m.User` object to the request scope, typically accessible as `request.user` or `connection.user`.
-   The `provide_user` dependency (defined in `app.server.security.py`) can be used for type-safe injection of the current `m.User` into route handler parameters.

### 9. Authorization and Guards
-   Security guards, defined in `app.server.security.py` (e.g., `requires_active_user`, `requires_superuser`, `requires_team_membership`, `requires_team_admin`), are applied to controllers or specific routes.
-   These guards operate on the `connection.user` object (the authenticated `m.User` instance).
-   They check user properties (e.g., `is_active`, `is_superuser`, roles, team memberships) to determine if the user has the necessary permissions for the requested resource or action.
-   If a guard check fails, it raises a `PermissionDeniedException`.

### 10. Data Transfer Objects (DTOs)
-   All request and response bodies related to authentication and user management (e.g., login credentials, user registration data, user profile information) MUST be defined as `msgspec.Struct` instances in `app.schemas.accounts` or other relevant schema modules.
-   Litestar handles automatic validation of incoming `msgspec.Struct` data and serialization of outgoing `msgspec.Struct` instances.

### 11. Error Handling
-   `litestar.exceptions.PermissionDeniedException` is the standard exception to be raised for authentication failures (e.g., invalid credentials, inactive account) and authorization failures (e.g., insufficient privileges as determined by guards).
-   `litestar.exceptions.NotAuthorizedException` might be used if a valid token is simply not present for a protected route.

### 12. OAuth Accounts (`UserOauthAccount`)
-   The `UserOauthAccount` model and its corresponding service (`UserOAuthAccountService`) are designed for linking user accounts to external OAuth providers (e.g., Google, GitHub).
-   This flow is complementary to the primary email/password JWT authentication. The specifics of the OAuth dance (redirects, token exchange with providers) are typically handled by a library like `httpx-oauth` and integrated into dedicated OAuth callback routes, eventually linking the external account to an internal `User` record.

## Conceptual Flow Summary

1.  **Login**: Client `POST /api/access/login` with credentials -> `AccessController` -> `UserService.authenticate` -> If OK, `security.auth.login` generates JWT -> Client receives JWT.
2.  **Authenticated Request**: Client sends request to protected endpoint with `Authorization: Bearer <JWT>` header.
3.  **Token Validation**: Litestar's `OAuth2PasswordBearerAuth` middleware validates JWT.
4.  **User Retrieval**: `current_user_from_token` is called -> `UserService` fetches user by email from JWT subject.
5.  **Guard Execution**: Route-specific guards check `request.user` properties.
6.  **Controller Logic**: If all checks pass, the controller handler is executed with `request.user` available.

This comprehensive flow ensures secure and consistent authentication and authorization throughout the application.
