---
description:
globs:
alwaysApply: false
---
# Testing with Pytest

## Objective
To ensure comprehensive test coverage, maintainable test suites, and effective use of Pytest features for both unit and integration testing.

## Context
- **Technologies**: Pytest, Python 3.13+, `msgspec` (for API DTOs).
- **Tools**: `pytest-asyncio` (for async tests), `pytest-mock` (for mocking), `pytest-cov` (for coverage), `pytest-xdist` (for parallel execution), `pytest-databases`.
- **Project Files**: `src/py/tests/`, `tests/`. `pyproject.toml` contains Pytest configuration (`tool.pytest.ini_options`).

## Rules

### Test Structure and Naming
- **File Naming**: Test files should be named `test_*.py` or `*_test.py` (prefer `test_*.py`).
- **Function Naming**: Test functions should be named `test_*` and clearly describe the scenario and expected outcome.
    - ✅ `def test_create_user_with_valid_data_returns_201_and_user_struct():`
    - ❌ `def test_user():`
- **Class Naming**: Test classes (if used for grouping related tests) should be named `Test*`.
    - ✅ `class TestUserService:`
- **Organization**:
    - `src/py/tests/unit/`: For unit tests, testing individual modules/functions/classes in isolation. Mocks are heavily used here.
    - `src/py/tests/integration/`: For integration tests, testing interactions between components (e.g., API endpoints with database and services).
- **Markers**: Use Pytest markers (`@pytest.mark.<marker_name>`) to categorize tests (e.g., `unit`, `integration`, `slow`). Markers are defined in `pyproject.toml`.
    - ✅ `@pytest.mark.integration`

### Test Content
- **AAA Pattern (Arrange, Act, Assert)**: Structure tests clearly using the Arrange, Act, Assert pattern.
    - ✅
      ```python
      # Assuming ItemRead is a msgspec.Struct
      async def test_get_item_success(item_id: UUID, client: AsyncTestClient, item_in_db: Item, item_read_struct: ItemRead):
          # Arrange (often handled by fixtures)
          # item_id, item_in_db, item_read_struct (expected output) are provided by fixtures.
          # client is the AsyncTestClient for making requests.

          # Act
          response = await client.get(f"/items/{item_id}")

          # Assert
          assert response.status_code == 200
          # Assuming response.json() can be decoded into the msgspec.Struct or a dict matching it
          response_data = msgspec.json.decode(response.content, type=ItemRead)
          assert response_data.id == item_id
          assert response_data.name == item_in_db.name # Or item_read_struct.name
      ```
- **Single Responsibility**: Each test should ideally verify one specific behavior or outcome.
- **Independence**: Tests must be independent and not rely on the state or outcome of other tests. Use fixtures for setup and teardown.
- **Mocking (`pytest-mock`)**: Use the `mocker` fixture from `pytest-mock` for mocking external dependencies or specific internal calls in unit tests. Avoid over-mocking.
    - ✅ `mocker.patch('app.services.some_service.some_object.external_call', return_value=...)`
- **Fixtures**: Utilize Pytest fixtures (`@pytest.fixture`) for setting up preconditions (e.g., test data, client instances, database sessions, `msgspec.Struct` instances for request/response data).
    - Define reusable fixtures in `conftest.py` files at appropriate directory levels.
    - Scope fixtures correctly (`function`, `class`, `module`, `session`).

### Assertions
- **Specific Assertions**: Use specific assertion functions.
- **`msgspec.Struct` Assertions**: When asserting API responses, decode the response into the expected `msgspec.Struct` and assert field values.
    - ✅ `actual_struct = msgspec.json.decode(response.content, type=ExpectedStruct)`
    - ✅ `assert actual_struct == expected_struct_fixture` (if structs support equality comparison and order is deterministic or using `msgspec.match_type`).

### Asynchronous Tests (`pytest-asyncio`)
- **`async def`**: Mark async test functions with `async def`.
- **Async Fixtures**: Use `@pytest_asyncio.fixture` for fixtures that need to perform async operations.

### Integration Tests
- **`AsyncTestClient`**: Use Litestar's `AsyncTestClient` for testing HTTP endpoints.
- **Database State**: Manage database state carefully. `pytest-databases` plugin helps.
- **Real Dependencies**: Integration tests should use real database connections and other in-process services where feasible. Mock external third-party services.
- **Request Data**: When sending data to endpoints (POST, PUT, PATCH), construct instances of the relevant `msgspec.Struct` and pass them to the client's `json=` parameter (httpx client will serialize it).

### Coverage (`pytest-cov`)
- **Aim for High Coverage**: Strive for high test coverage.
- **Meaningful Tests**: Focus on meaningful tests.

## Exceptions
- E2E tests might have different structures.
- Performance-specific tests have different patterns.
